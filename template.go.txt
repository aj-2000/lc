// Code generated by generator.go; DO NOT EDIT.

<---------Autogenerated Code Start-------->

import (
	"container/heap"
	"fmt"
	"strconv"
)

func dijkstra(g *Graph, start, end string) ([]string, int) {
	// Min-heap priority queue
	pq := NewMinHeap()
	heap.Init(pq)

	// Distance and previous node tracking
	distances := make(map[string]int)
	prev := make(map[string]string)
	visited := make(map[string]bool)

	// Initialize distances
	g.ForEachVertex(func(v *Vertex) {
		distances[v.GetKey()] = 1<<31 - 1 // Max int (infinity)
	})

	distances[start] = 0

	heap.Push(pq, &Item{Value: start, Priority: 0})

	for pq.Len() > 0 {
		item := heap.Pop(pq).(*Item)
		node := item.Value

		if node == end {
			break
		}

		visited[node] = true
		g.GetVertex(node).ForEachEdge(func(neighbor string, weight int) {
			if !visited[neighbor] {
				newDist := distances[node] + weight
				if newDist < distances[neighbor] {
					distances[neighbor] = newDist
					prev[neighbor] = node
					heap.Push(pq, &Item{Value: neighbor, Priority: newDist})
				}
			}
		})
	}

	// Reconstruct shortest path
	path := []string{}
	for at := end; at != ""; at = prev[at] {
		path = append([]string{at}, path...)
	}

	// If path doesn't contain the start node, no valid path exists
	if len(path) == 0 || path[0] != start {
		return nil, -1
	}

	return path, distances[end]
}

type Vertex struct {
	key   string
	edges map[string]int
}

func (v *Vertex) GetKey() string {
	return v.key
}

func (v *Vertex) ForEachEdge(f func(string, int)) {
	for key, weight := range v.edges {
		f(key, weight)
	}
}

type Graph struct {
	vertices map[string]*Vertex
}

func NewGraph() *Graph {
	return &Graph{vertices: make(map[string]*Vertex)}
}

func (g *Graph) GetAllVertex() []*Vertex {
	vertices := make([]*Vertex, 0)
	for _, v := range g.vertices {
		vertices = append(vertices, v)
	}
	return vertices
}

func (g *Graph) AddVertex(key string) {
	if _, ok := g.vertices[key]; ok {
		return
	}
	g.vertices[key] = &Vertex{key, make(map[string]int)}
}

func (g *Graph) AddDirectedEdge(from, to string, weight int) {
	g.vertices[from].edges[to] = weight
}

func (g *Graph) AddUnDirectedEdge(from, to string, weight int) {
	g.AddDirectedEdge(from, to, weight)
	g.AddDirectedEdge(to, from, weight)
}

func (g *Graph) RemoveDirectedEdge(from, to string) {
	delete(g.vertices[from].edges, to)
}

func (g *Graph) RemoveUnDirectedEdge(from, to string) {
	g.RemoveDirectedEdge(from, to)
	g.RemoveDirectedEdge(to, from)
}

func (g *Graph) ForEachVertex(f func(*Vertex)) {
	for _, v := range g.vertices {
		f(v)
	}
}

func (g *Graph) GetVertex(key string) *Vertex {
	return g.vertices[key]
}

func (g *Graph) FindShortestPath(start, end string) ([]string, int) {
	return dijkstra(g, start, end)
}

func (g *Graph) FindBridges() [][]string {
	return tarzans(g)
}

func (g *Graph) Print() {
	graph := ""
	for _, v := range g.vertices {
		graph += fmt.Sprintf("%s -> ", v.GetKey())
		v.ForEachEdge(func(neighbor string, weight int) {
			graph += fmt.Sprintf("%s[%d], ", neighbor, weight)
		})
		graph += "\n"
	}
	fmt.Println(graph)
}

func AI2AS(a []int) []string {
	result := make([]string, len(a))
	for i := 0; i < len(a); i++ {
		result[i] = strconv.Itoa(a[i])
	}
	return result
}

func AS2AI(a []string) ([]int, error) {
	result := make([]int, len(a))
	for i := 0; i < len(a); i++ {
		num, err := strconv.Atoi(a[i])
		if err != nil {
			return nil, fmt.Errorf("failed to convert %s to int", a[i])
		} else {
			result[i] = num
		}
	}
	return result, nil
}

func AAI2AAS(a [][]int) [][]string {
	result := make([][]string, len(a))
	for i := 0; i < len(a); i++ {
		result[i] = AI2AS(a[i])
	}
	return result
}

func AAS2AAI(a [][]string) ([][]int, error) {
	result := make([][]int, len(a))
	for i := 0; i < len(a); i++ {
		nums, err := AS2AI(a[i])
		if err != nil {
			return nil, err
		} else {
			result[i] = nums
		}
	}
	return result, nil
}

// Item represents a node in the priority queue
type Item struct {
	Value    string
	Priority int
}

// PriorityQueue implements a heap interface
type PriorityQueue struct {
	items []*Item
	less  func(i, j int) bool
}

func (pq PriorityQueue) Len() int           { return len(pq.items) }
func (pq PriorityQueue) Less(i, j int) bool { return pq.less(i, j) }
func (pq PriorityQueue) Swap(i, j int)      { pq.items[i], pq.items[j] = pq.items[j], pq.items[i] }

func (pq *PriorityQueue) Push(x any) {
	item := x.(*Item)
	pq.items = append(pq.items, item)
}

func (pq *PriorityQueue) Pop() any {
	old := pq.items
	n := len(old)
	item := old[n-1]
	pq.items = old[:n-1]
	return item
}

func NewMinHeap() *PriorityQueue {
	pq := &PriorityQueue{}
	pq.less = func(i, j int) bool { return pq.items[i].Priority < pq.items[j].Priority }
	heap.Init(pq)
	return pq
}

func NewMaxHeap() *PriorityQueue {
	pq := &PriorityQueue{}
	pq.less = func(i, j int) bool { return pq.items[i].Priority > pq.items[j].Priority }
	heap.Init(pq)
	return pq
}

type Stack struct {
	items []string
}

func (s *Stack) Push(data string) {
	s.items = append(s.items, data)
}

func (s *Stack) Pop() error {
	if s.IsEmpty() {
		return fmt.Errorf("stack is empty")
	}
	s.items = s.items[:len(s.items)-1]
	return nil
}

func (s *Stack) Top() (string, error) {
	if s.IsEmpty() {
		return "", fmt.Errorf("stack is empty")
	}
	return s.items[len(s.items)-1], nil
}

func (s *Stack) IsEmpty() bool {
	return len(s.items) == 0
}

func (s *Stack) Size() int {
	return len(s.items)
}

func (s *Stack) Print() {
	for _, item := range s.items {
		fmt.Print(item, " ")
	}
	fmt.Println()
}

func (s *Stack) Clear() {
	s.items = []string{}
}

func (s *Stack) ForEach(f func(string)) {
	for _, item := range s.items {
		f(item)
	}
}

func NewStack() *Stack {
	return &Stack{}
}

func tarzans(g *Graph) [][]string {
	id := 0
	ids, low, vis := make(map[string]int), make(map[string]int), make(map[string]bool)
	var startVertex string

	g.ForEachVertex(func(vtx *Vertex) {
		if startVertex == "" {
			startVertex = vtx.GetKey()
		}
	})

	if startVertex == "" {
		return nil
	}

	var bridges [][]string

	var dfs func(v, parent string)
	dfs = func(v, parent string) {
		vis[v] = true
		ids[v] = id
		low[v] = id
		id++

		g.GetVertex(v).ForEachEdge(func(n string, w int) {
			if n == parent {
				return
			}
			if !vis[n] {
				dfs(n, v)
				low[v] = min(low[v], low[n])
				if ids[v] < low[n] {
					bridges = append(bridges, []string{v, n})
				}
			} else {
				low[v] = min(low[v], ids[n])
			}
		})
	}

	dfs(startVertex, "")

	return bridges
}


// <---------Autogenerated Code End-------->
